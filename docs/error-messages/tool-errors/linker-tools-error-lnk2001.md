---
title: 링커 도구 오류 LNK2001 | Microsoft Docs
ms.custom: ''
ms.date: 05/17/2017
ms.technology:
- cpp-diagnostics
ms.topic: error-reference
f1_keywords:
- LNK2001
dev_langs:
- C++
helpviewer_keywords:
- LNK2001
ms.assetid: dc1cf267-c984-486c-abd2-fd07c799f7ef
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 78dc0c0a3a030ecb88d7138484e2c64e145f69ec
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
---
# <a name="linker-tools-error-lnk2001"></a>링커 도구 오류 LNK2001
확인 되지 않은 외부 기호 "*기호*"  
  
컴파일된 코드에서는 참조 또는 호출 *기호*이지만, 그에 라이브러리 또는 개체 파일을 링커에 지정 기호가 정의 되지 않습니다.  
  
이 오류 메시지 다음에 심각한 오류 [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md)합니다. LNK1120 오류를 해결 하려면 모든 LNK2001 및 LNK2019 오류를 수정 해야 합니다.  
  
## <a name="possible-causes"></a>가능한 원인  
  
이 오류가 발생 하는 방법은 여러 가지가 있지만 링커 없습니다 된 변수 또는 함수에 대 한 참조를 포함 하는 모든 *해결*, 또는 찾기에 대 한 정의입니다. 기호가 없을 때 확인할 수 있습니다 *선언*, 하지는 않지만 *정의*이므로 다른 소스 파일 또는 라이브러리에는 정의가 있을 수 있습니다. 기호 참조 되었지만 정의 되지 않았습니다. 된 경우 링커 오류가 발생 합니다.  
  
### <a name="coding-issues"></a>코딩 문제  
  
이 오류는 일치 하지 않는 대/소문자 소스 코드 또는 모듈 정의 (.def)에 발생할 수 있습니다 파일입니다. 예를 들어 변수에 이름을 `var1` 한 c + +에서 원본 파일 및로 액세스 하려고 `VAR1` ,이 오류가 생성 됩니다. 이 문제를 해결 하려면 사용 하 여는 일관성 있게 철자를 입력 하 고 이름은 대/소문자를 합니다.  
  
이 오류를 사용 하는 프로젝트에서 발생할 수 있습니다 [함수 인라이닝](../../error-messages/tool-errors/function-inlining-problems.md) 아닌 헤더 파일에 소스 파일에는 함수를 정의 하는 경우. 정의 된 소스 파일 외부 인라인 된 함수를 볼 수 없습니다. 이 문제를 해결 하려면 선언 된 헤더에 인라인 된 함수를 정의 합니다.  
  
이 오류는 사용 하지 않고 c + + 프로그램에서 C 함수를 호출 하는 경우에 발생할 수 있습니다는 `extern "C"` C 함수에 대 한 선언 합니다. 컴파일러는 C 및 c + + 코드에 대 한 서로 다른 내부 기호 명명 규칙을 사용 하 고 기호를 확인할 때 링커가 검색 하는 내부 기호 이름입니다. 이 문제를 해결 하려면 사용 하 여 프로그램 `extern "C"` 모든 선언 하면 컴파일러가 해당 기호에 대 한 C 내부 명명 규칙을 사용 하는 c + + 코드에 사용 되는 C 함수의 래퍼입니다. 컴파일러 옵션 [/Tp](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) 및 [/Tc](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) 하면 컴파일러가 파일 이름 확장명에 관계 없이 파일을 c + + 또는 C로 컴파일합니다. 이러한 옵션에는 내부 함수 이름은 원하는 것과 다른 발생할 수 있습니다.  
  
이 오류는 함수 또는 외부 링크를 사용 하지 않는 데이터를 참조 하려고 하 여 발생할 수 있습니다. C + +에서 인라인 함수 및 `const` 으로 명시적으로 지정 되지 않은 데이터는 내부 링크 `extern`합니다. 이 문제를 해결 하려면 명시적을 사용 하 여 `extern` 정의 원본 파일 외부 기호에 대 한 선언을 참조 합니다.  
  
이 오류를 때문일 수 있습니다는 [함수 본문 또는 변수 누락](../../error-messages/tool-errors/missing-function-body-or-variable.md) 정의 합니다. 이 오류는 선언, 정의 하지 않음, 변수, 함수 또는 클래스 코드에서 때 일반적입니다. 컴파일러는 함수 프로토타입이 필요 또는 `extern` 함수 코드 또는 변수에 공백이 있기 때문에 오류, 하지만 링커 하지 않고 개체 파일을 생성 하는 변수 선언 함수를 호출 하거나 변수에 대 한 참조를 확인할 수 없습니다 예약 되어 있습니다. 이 문제를 해결 하려면 모든 참조 된 함수 및 변수는 소스 파일 또는 링크에 포함 된 라이브러리에 정의 완벽 하 게 되어 있는지를 확인 합니다.  
  
이 오류를 반환 및 매개 변수 형식 또는 함수 정의 일치 하지 않는 호출 규칙을 사용 하는 함수 호출에 의해 발생할 수 있습니다. C + + 개체 파일에 [이름 데코레이션](../../error-messages/tool-errors/name-decoration.md) 호출 규칙, 클래스 또는 네임 스페이스 범위 및 함수 반환 형식과 매개 변수 유형의 경우 일치 하도록 기호를 호출 하기 때문에 사용 되는 데코 레이트 된 최종 함수 이름에 통합 다른 개체 파일에서 함수 확인 됩니다. 이 문제를 해결 하려면 선언, 정 및 모든 함수 호출에 사용 동일한 범위, 유형 및 호출 규칙을 확인 합니다.  
  
함수 프로토타입 클래스 정의에 포함 되었지만 되지 못한 경우 c + + 코드에서이 오류가 발생할 수 있습니다 [구현을 포함](../../error-messages/tool-errors/missing-function-body-or-variable.md) 함수를 호출 하는 것입니다. 이 문제를 해결 하려면 클래스의 멤버를 선언 된 모든 호출에 대 한 정의 제공 해야 합니다.  
  
이 오류는 추상 기본 클래스에서 순수 가상 함수를 호출 하려고 하 여 발생할 수 있습니다. 순수 가상 함수에 기본 클래스 구현이 없습니다. 이 문제를 해결 하려면 가상 함수 호출 모두는 구현 되었는지 확인 합니다.  
  
이 오류는 함수 내에서 선언 된 변수를 사용 하려는 경우에 발생할 수 있습니다 ([지역 변수](../../error-messages/tool-errors/automatic-function-scope-variables.md)) 해당 함수의 범위 밖에 있습니다. 이 문제를 해결 하려면 변수 범위에 있지 않은에 대 한 참조를 제거 하거나 더 높은 범위 변수 이동 합니다.  
  
이 오류는 ATL 프로젝트의 릴리스 버전 빌드 CRT 시작 코드가 필요 하다는 메시지를 생성 하는 경우에 발생할 수 있습니다. 이 문제를 해결 하려면 다음 중 하나를 수행  
  
-   제거 `_ATL_MIN_CRT` 전처리기의 목록에서 CRT 시작 코드가 포함 될 수 있도록 정의 합니다. 참조 [일반 속성 페이지 (프로젝트)](../../ide/general-property-page-project.md) 자세한 정보에 대 한 합니다.  
  
-   가능 하면 CRT 시작 코드를 필요로 하는 CRT 함수에 대 한 호출을 제거 합니다. 해당 Win32 형식 대신 사용 합니다. 사용 예를 들어 `lstrcmp` 대신 `strcmp`합니다. CRT 시작 코드를 필요로 하는 알려진된 함수에 문자열 및 부동 소수점 함수가 중 일부입니다.  
  
### <a name="compilation-and-link-issues"></a>컴파일 및 링크 문제  
  
프로젝트 라이브러리에 대 한 참조를 손실 된 경우이 오류가 발생할 수 있습니다 (합니다. LIB) 또는 개체 (합니다. OBJ) 파일입니다. 이 문제를 해결 하려면 필요한 라이브러리 또는 개체 파일에 대 한 참조를 프로젝트에 추가 합니다. 자세한 내용은 참조 [링커 입력으로 사용 하는.lib 파일](../../build/reference/dot-lib-files-as-linker-input.md)합니다.  
  
사용 하는 경우이 오류가 발생할 수 있습니다는 [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) 또는 [/Zl](../../build/reference/zl-omit-default-library-name.md) 옵션입니다. 이러한 옵션을 지정 하면 명시적으로 포함 하지 않으면 필요한 코드를 포함 하는 라이브러리 프로젝트에 연결 되지 않습니다. 이 문제를 해결 하려면 명시적으로 링크 명령줄에 사용할 모든 라이브러리를 포함 합니다. 이러한 옵션을 사용 하는 경우 많은 누락 CRT 또는 표준 라이브러리 함수 이름을 표시 하는 경우 명시적으로 링크의 CRT 및 표준 라이브러리 Dll 또는 라이브러리 파일을 포함 합니다.  

사용 하 여 컴파일하는 경우는 **/clr** 옵션,.cctor에 대 한 누락 된 참조가 있을 수 있습니다. 이 문제를 해결 하려면 참조 [혼합형 어셈블리 초기화](../../dotnet/initialization-of-mixed-assemblies.md) 자세한 정보에 대 한 합니다.  
  
이 오류는 응용 프로그램의 디버그 버전을 빌드할 때 릴리스 모드 라이브러리에 연결 되는 경우에 발생할 수 있습니다. 마찬가지로, 옵션을 사용할 경우 **/MTd** 또는 **/MDd** 정의 또는 `_DEBUG` 다음 릴리스 라이브러리에 연결 하 고, 다른 문제와 많은 잠재적 해결 되지 않은 외부 소요 될 수 있습니다. 디버그 라이브러리와 릴리스 모드 빌드 연결도 유사한 문제가 발생 합니다. 이 문제를 해결 하려면 소매 라이브러리에 일반 정품에서 빌드 및 디버그 라이브러리를 사용 하 여 디버그 빌드에서 이어야 합니다.  
  
이 오류 코드는 라이브러리의 한 버전에서 기호를 참조 하지만 서로 다른 버전의 링커를 라이브러리를 제공 하는 경우에 발생할 수 있습니다. 일반적으로 개체 파일 또는 라이브러리가 다른 버전의 컴파일러에 대해 작성 된 혼합할 수 없습니다. 새 버전에 제공 되는 라이브러리를 반대로 및 이전 버전에 포함 된 라이브러리에서 찾을 수 없는 기호를 포함할 수 있습니다. 이 문제를 해결 하려면 함께 연결 하기 전에 모든 개체 파일 및 라이브러리와 동일한 버전의 컴파일러를 빌드하십시오.  
  
-  도구 &#124; 옵션 &#124; 프로젝트 &#124; 라이브러리 파일 선택 영역에서 VC + + 디렉터리 대화 상자, 라이브러리 검색 순서를 변경할 수 있습니다. 프로젝트의 속성 페이지 대화 상자에서 링커 폴더 만료 될 수 있는 경로 포함할 수도 있습니다.  
  
-  이 문제는 (다른 위치에), 새로운는 SDK가 설치 및 검색 순서 새 위치를 가리키도록 업데이트 되지 않습니다 때 나타날 수 있습니다. 일반적으로 넣어야 경로를 새 SDK 포함 및 라이브러리의 기본 Visual c + + 위치 앞에 디렉터리입니다. 또한 포함 된 경로 포함 하는 프로젝트 경로 이전 경로 유효 하지만 서로 다른 위치에 설치 하는 새 버전에서 추가 된 새로운 기능에 대해 만료 된를 여전히 가리킬 수 있습니다.  
  
-   명령줄에서 작성 하 고 고유한 환경 변수를 만든 도구, 라이브러리 및 헤더 파일의 경로 동일한 버전으로 이동 있는지 확인 합니다. 자세한 내용은 참조 [명령줄 빌드에 맞는 경로 및 환경 변수 설정](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md)
  
여기에 현재 없는 표준에 대 한 [c + + 이름 지정](../../error-messages/tool-errors/name-decoration.md) 간에 서로 다른 버전의 컴파일러 또는 컴파일러 공급 업체 간에 합니다. 따라서 다른 컴파일러로 컴파일한 개체 파일에 연결 될 수 있습니다 같은 명명 체계가 생성 없고 오류 LNK2001 합니다.  
  
[혼합 인라인이 아닌 컴파일 옵션](../../error-messages/tool-errors/function-inlining-problems.md) 서로 다른 모듈에서 LNK2001 발생할 수 있습니다. C + + 라이브러리 함수 인라이닝 설정 만들어집니다 (**/Ob1** 또는 **/Ob2**) 하지만 함수를 설명 하는 해당 헤더 파일의 인라인 처리 해제 되어 (없음 `inline` 키워드)를이 오류 발생합니다. 이 문제를 해결 하려면 함수 정의 `inline` 다른 소스 파일에 포함 하는 헤더 파일에 있습니다.  
  
사용 하는 경우는 `#pragma inline_depth` 컴파일러 지시문을 해야는 [2 이상 집합의 값](../../error-messages/tool-errors/function-inlining-problems.md), 또한를 사용 해야 하 고는 [/Ob1](../../build/reference/ob-inline-function-expansion.md) 또는 [/Ob2](../../build/reference/ob-inline-function-expansion.md) 컴파일러 옵션입니다.  
  
이 오류는 링크를 생략 하면 리소스 전용 DLL을 만들 때 /NOENTRY 옵션입니다. 이 문제를 해결 하려면 /NOENTRY 옵션을 link 명령에 추가 합니다.  
  
이 오류는 프로젝트에 잘못 된 /SUBSYSTEM 또는 /ENTRY 설정을 사용 하는 경우에 발생할 수 있습니다. 예를 들어 콘솔 응용 프로그램을 작성 하 고 /subsystem 확인 되지 않은 외부 오류가 발생에 대 한 `WinMain`합니다. 이 문제를 해결 하려면 프로젝트 형식에 대 한 옵션을와 일치 해야 합니다. 이러한 옵션 및 진입점에 대 한 자세한 내용은 참조는 [/SUBSYSTEM](../../build/reference/subsystem-specify-subsystem.md) 및 [/ENTRY](../../build/reference/entry-entry-point-symbol.md) 링커 옵션입니다.  
  
### <a name="exported-symbol-issues"></a>내보낸된 기호 문제  
  
이 오류는.def 파일에 나열 된 내보내기를 찾을 수 없을 때 발생 합니다. 존재 하지 않는 것은 철자가 잘못 또는 c + + 데코 레이트 된 이름을 사용 하 여 때문일 수 있습니다. .Def 파일 데코 레이트 된 이름을 사용할 수 없습니다. 이 문제를 해결 하려면 불필요 한 내보내기를 제거 하 고 사용 `extern "C"` 내보낸된 기호에 대 한 선언이 있습니다.  
  
## <a name="what-is-an-unresolved-external-symbol"></a>확인 되지 않은 외부 기호는 무엇입니까?  
  
A *기호* 함수 또는 컴파일된 개체 파일 또는 라이브러리에서 내부적으로 사용 하는 전역 변수에 대 한 이름입니다. 기호는 *정의* 함수 본문에 컴파일된 코드 위치는 함수 또는 전역 변수에 대해 저장소가 할당 개체 파일에 있습니다. *외부 기호* 기호는 *참조*, 즉, 사용 또는 하나의 개체 파일에서 호출 뿐 아니라 다른 라이브러리 또는 개체 파일에 정의 합니다. *내보낸 기호* 개체 파일 또는 정의 하는 라이브러리에서 공개적으로 사용할 수 있는 하나입니다. 링커 해야 *해결*, 또는 응용 프로그램 또는 DLL에 연결 될 때 개체 파일에서 참조 하는 모든 외부 기호에 대해 일치 하는 정의 확인해 보세요. 연결 된 파일에서 일치 하는 내보낸된 기호를 검색 하 여 외부 기호를 확인할 수 없는 경우에 링커 오류가 발생 합니다.    
  
## <a name="use-the-decorated-name-to-find-the-error"></a>데코 레이트 된 이름을 사용 하 여 오류를 찾으려면
  
C + + 컴파일러 및 링커 사용 [이름 데코레이션](../../error-messages/tool-errors/name-decoration.md)라고도 *이름 장식*, 변수 형식 또는 반환 형식, 매개 변수 형식, 범위 및 호출 하는 방법에 대 한 추가 정보를 인코딩합니다 규칙 기호 이름에는 함수입니다. 이 데코 레이트 된 이름은 링커가 외부 기호를 확인 하기 위해 검색 기호 이름이입니다.  
  
추가 정보 일부 기호 이름 때문에 링크 오류 함수 또는 변수 선언 정확히 일치 하지 않는 함수 또는 변수를 정의 하는 경우 발생할 수 있습니다. 이 동일한 헤더 파일은 소스 파일을 컴파일할 때 다른 컴파일러 플래그를 사용 하는 경우 호출 코드 및 정의 코드를 둘 다에 사용 하는 경우에 발생할 수 있습니다. 예를 들어, 사용 하도록 코드를 컴파일한 경우이 오류가 발생할 수 있습니다는 `__vectorcall` 클라이언트가 기본값을 사용 하 여 호출 하는 라이브러리에 연결할 수 있지만 호출 규칙 `__cdecl` 또는 `__fastcall` 호출 규칙입니다. 이 경우 기호 일치 하지 않는 호출 규칙 다르기 때문에   
  
이러한 종류의 오류 원인을 확인 하기 위해 링커 오류 메시지가 모두 "친숙 한 이름을 표시," 확인 되지 않은 외부 기호에 대 한 괄호 안에 데코 레이트 된 이름 및 소스 코드에 사용 되는 이름입니다. 다른 트 데코 레이 된 이름과 비교할 수 있어야 하는 데코레이팅된 이름을 변환 하는 방법을 알 필요가 없습니다. 예상 되는 기호가 이름과 실제 기호 이름을 비교할 컴파일러와 함께 제공 되는 명령줄 도구를 사용할 수 있습니다.  

-   [/exports](../../build/reference/dash-exports.md) 및 [/기호](../../build/reference/symbols.md) .dll 및 개체 또는 라이브러리 파일에 정의 된 기호는 검색할 DUMPBIN 명령줄 도구의 옵션 수 있습니다. 내보낸 데코레이팅된과 이름이 일치 하는 트 데코 레이 된 이름이 링커가 검색 있는지 확인 하는 데 사용할 수 있습니다.  
  
경우에 따라 링커가 기호에 대 한 데코 레이트 된 이름을만 보고할 수 있습니다. UNDNAME 명령줄 도구를 사용 하 여 데코레이팅되지 않은 형태의 데코레이팅된 이름 가져올 수 있습니다.  
  
## <a name="additional-resources"></a>추가 자료  
  
LNK2001에 대 한 가능한 원인 및 해결 하는 방법에 대 한 자세한 내용은 스택 오버플로 질문을 참조 하십시오. [정의 되지 않은 참조/확인 되지 않은 외부 기호 오류가 란 무엇이 고 어떻게 해결 하나요?](http://stackoverflow.com/q/12573816/2002113)합니다.  

