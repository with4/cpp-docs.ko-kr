---
title: "우선 순위 및 식 평가 순서 | Microsoft Docs"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- associativity of operators [C++]
- precedence [C++], operators
- data binding [C++], operator precedence
- operators [C++], precedence
ms.assetid: 201f7864-0c51-4c55-9d6f-39c5d013bcb0
caps.latest.revision: 8
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Human Translation
ms.sourcegitcommit: 3f91eafaf3b5d5c1b8f96b010206d699f666e224
ms.openlocfilehash: b6b455077861557bcdba03d0b9bd714d475961f5
ms.lasthandoff: 04/01/2017

---
# <a name="precedence-and-order-of-evaluation"></a>우선 순위 및 식 평가 순서
C 연산자의 우선 순위와 결합성은 식의 피연산자 그룹화 및 계산에 영향을 줍니다. 연산자의 우선 순위는 우선 순위가 더 높거나 낮은 다른 연산자가 있는 경우에만 의미가 있습니다. 우선 순위가 높은 연산자가 있는 식이 먼저 계산됩니다. 우선 순위는 단어 "바인딩"으로도 설명할 수 있습니다. 우선 순위가 높은 연산자는 더욱 엄격한 바인딩을 가져야 합니다.  
  
 다음 표는 C 연산자의 우선 순위(피연산자 계산 순서)와 결합성을 우선 순위가 높은 것부터 낮은 것 순서로 나열 및 요약한 것입니다. 여러 개의 연산자가 함께 표시된 경우, 해당 연산자는 우선 순위가 같으므로 각각의 연관성에 따라 계산됩니다. 표에 나온 연산자는 [후위 연산자](../c-language/postfix-operators.md)를 처음에 다루는 단원에 설명되어 있습니다. 이 단원의 나머지 부분에서는 우선 순위 및 결합성에 대한 일반적인 정보를 제공합니다.  
  
### <a name="precedence-and-associativity-of-c-operators"></a>C 연산자의 우선 순위 및 결합성  
  
|Symbol1|연산 형식|associativity|  
|-------------|-----------------------|-------------------|  
|**[ ] ( ) . ->** 후위 `++` 및 후위 **--**|식|왼쪽에서 오른쪽|  
|전위 `++` 및 전위 **-- sizeof &   \*   + - ~ !**|단항|오른쪽에서 왼쪽|  
|*형식 캐스팅*|단항|오른쪽에서 왼쪽|  
|**\* / %**|곱하기|왼쪽에서 오른쪽|  
|**+ -**|더하기|왼쪽에서 오른쪽|  
|**<\< >>**|비트 시프트|왼쪽에서 오른쪽|  
|**\< > \<= >=**|관계|왼쪽에서 오른쪽|  
|**== !=**|같음|왼쪽에서 오른쪽|  
|**&**|비트 AND|왼쪽에서 오른쪽|  
|**^**|비트 제외 OR|왼쪽에서 오른쪽|  
|**&#124;**|비트 포함 OR|왼쪽에서 오른쪽|  
|**&&**|논리 AND|왼쪽에서 오른쪽|  
|`&#124;&#124;`|논리 OR|왼쪽에서 오른쪽|  
|**? :**|조건식|오른쪽에서 왼쪽|  
|**= \*= /= %=**<br /><br /> **+= -= <\<= >>=&=**<br /><br /> **^= &#124;=**|단순 및 복합 할당2|오른쪽에서 왼쪽|  
|**,**|순차적 계산|왼쪽에서 오른쪽|  
  
 1. 연산자는 내림차순 우선 순위로 나열됩니다. 여러 연산자가 같은 줄 또는 그룹에 표시된 경우, 해당 연산자는 우선 순위가 같습니다.  
  
 2. 모든 단순 및 복합 할당 연산자의 우선 순위는 같습니다.  
  
 식에 우선 순위가 같은 여러 연산자가 포함될 수 있습니다. 여러 연산자가 하나의 식에 같은 수준으로 표시된 경우, 오른쪽에서 왼쪽 또는 왼쪽에서 오른쪽으로 연산자의 연관성에 따라 계산이 진행됩니다. 계산의 방향은 같은 수준에 있는 곱하기(**\***), 더하기(**+**) 또는 이진 비트(**& &#124; ^**) 연산자가 둘 이상 포함된 식의 결과에 영향을 주지 않습니다. 연산 순서는 언어에 따라 정의되지 않습니다. 컴파일러는 일관된 결과를 보장할 수 있는 경우 어떠한 순서로든 이러한 식을 자유롭게 계산합니다.  
  
 순차적 계산(**,**), 논리적 AND(**&&**), 논리적 OR(`||`), 조건식(**? :**) 및 함수 호출 연산자만 시퀀스 위치를 구성하므로 피연산자에 대한 특정 계산 순서를 보장합니다. 함수 호출 연산자는 함수 식별자 뒤에 오는 괄호의 집합입니다. 순차적 계산 연산자(**,**)는 피연산자를 왼쪽에서 오른쪽으로 계산합니다. 함수 호출의 쉼표 연산자는 순차적 계산 연산자와 동일하지 않으며 동일하다는 보장도 제공하지 않습니다. 자세한 내용은 [시퀀스 위치](../c-language/c-sequence-points.md)를 참조하세요.  
  
 논리 연산자도 피연산자를 왼쪽에서 오른쪽으로 계산합니다. 하지만 식의 결과를 결정하는 데 필요한 최소 피연산자 수를 계산합니다. 이것을 "단락(short-circuit)" 계산이라고 합니다. 따라서 식의 일부 피연산자는 계산될 수 없습니다. 예를 들어, 식에서  
  
```  
x && y++  
```  
  
 두 번째 피연산자, `y++`는 `x`가 true(0 이외의 값)인 경우에만 계산됩니다. 따라서 `y`는 `x`가 false(0)인 경우 증가하지 않습니다.  
  
 **예제**  
  
 다음 목록에서는 컴파일러가 자동으로 몇 가지 예제 식을 바인딩하는 방법을 보여 줍니다.  
  
|식|자동 바인딩|  
|----------------|-----------------------|  
|`a & b &#124;&#124; c`|`(a & b) &#124;&#124; c`|  
|`a = b &#124;&#124; c`|`a = (b &#124;&#124; c)`|  
|`q && r &#124;&#124; s--`|`(q && r) &#124;&#124; s--`|  
  
 첫 번째 식에서 비트 AND 연산자(`&`)는 논리 OR 연산자(`||`)보다 우선 순위가 높기 때문에 `a & b`가 논리 OR 연산의 첫 번째 피연산자가 됩니다.  
  
 두 번째 식에서 논리 OR 연산자(`||`)는 단순 할당 연산자(`=`)보다 우선 순위가 높습니다. 따라서 `b || c`는 할당에서 오른쪽 피연산자 그룹이 됩니다. `a`에 할당되는 값은 0 또는 1입니다.  
  
 세 번째 식은 예기치 않은 결과가 발생할 수 있는 올바른 식을 보여 줍니다. 논리 AND 연산자(`&&`)는 논리 OR 연산자(`||`)보다 우선 순위가 높기 때문에 `q && r`은 단일 피연산자 그룹이 됩니다. 논리 연산자는 피연산자가 왼쪽에서 오른쪽으로 계산되도록 보장하므로 `q && r`은 `s--`보다 먼저 계산됩니다. 그러나 `q && r`이 0 이외의 값으로 계산되는 경우, `s--`는 계산되지 않고 `s`는 줄어들지 않습니다. `s`가 줄어들지 않아 프로그램에 문제가 발생할 경우 `s--`가 식의 첫째 피연산자로 표시되거나 `s`가 별도 연산에서 감소됩니다.  
  
 다음 식은 잘못되었으며 컴파일 시 진단 메시지를 생성합니다.  
  
|잘못된 식|기본 그룹화|  
|------------------------|----------------------|  
|`p == 0 ? p += 1: p += 2`|`( p == 0 ? p += 1 : p ) += 2`|  
  
 이 식에서는 같음 연산자(`==`)의 우선 순위가 가장 높으므로 `p == 0`은 피연산자 그룹이 됩니다. 조건식 연산자(`? :`)의 우선 순위는 그 다음으로 높습니다. 첫 번째 피연산자는 `p == 0`이고, 두 번째 피연산자는 `p += 1`입니다. 그러나 `p`가 복합 할당 연산자보다 조건식 연산자에 더 가까이 바인딩되기 때문에 마지막 조건식 연산자의 피연산자는 `p += 2`가 아닌 `p`로 간주됩니다. `+= 2`에 왼쪽 피연산자가 없기 때문에 구문 오류가 발생합니다. 이러한 종류의 오류를 방지하고 보다 읽기 쉬운 코드를 생성하려면 괄호를 사용해야 합니다. 예를 들어, 아래와 같이 괄호를 사용하여 앞의 예제를 수정하고 명확하게 만들 수 있습니다.  
  
```  
( p == 0 ) ? ( p += 1 ) : ( p += 2 )  
```  
  
## <a name="see-also"></a>참고 항목  
 [C 연산자](../c-language/c-operators.md)
