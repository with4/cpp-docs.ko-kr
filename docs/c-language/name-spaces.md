---
title: "네임스페이스 | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
  - "C"
helpviewer_keywords: 
  - "열거형 태그"
  - "네임스페이스[C++]"
  - "이름[C++], 선언 요소"
  - "구조체 태그"
  - "태그, 구조체 태그"
  - "union 키워드[C]"
  - "union 키워드[C], 태그"
ms.assetid: b4bda1d1-cb5e-4f60-ac2b-29af93d8a9a2
caps.latest.revision: 7
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# 네임스페이스
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

컴파일러가 "네임스페이스"를 설정하여 여러 종류의 항목에 사용된 식별자를 구별합니다.  각 네임스페이스에 있는 이름이 고유해야 충돌을 피할 수 있지만 네임스페이스 안에 같은 이름이 두 번 이상 나타날 수도 있습니다.  즉, 항목이 서로 다른 네임스페이스에 있을 경우 2개 이상의 다른 항목에 같은 식별자를 사용할 수 있습니다.  컴파일러는 프로그램에서 식별자의 구문 컨텍스트를 기반으로 참조를 확인할 수 있습니다.  
  
> [!NOTE]
>  네임스페이스의 제한된 C 개념과 C\+\+ "네임 스페이스" 기능을 혼동하지 마십시오.  자세한 내용은 C\+\+ 언어 참조의 [네임스페이스](../cpp/namespaces-cpp.md)를 참조하십시오.  
  
 이 목록에서는 C에 사용되는 네임스페이스를 설명합니다.  
  
 문 레이블  
 명명된 문 레이블은 문의 일부입니다.  문 레이블의 정의는 항상 콜론 앞에 오지만 **case** 레이블의 일부분이 아닙니다.  항상 `goto` 키워드 뒤에 문 레이블을 사용합니다.  문 레이블은 다른 이름이나 다른 함수의 레이블 이름과 다르지 않아도 됩니다.  
  
 구조체, 공용 구조체 및 열거형 태그  
 이 태그는 구조체, 공용 구조체 및 열거형 형식 지정자의 일부이며, 사용될 경우 예약된 단어 `struct`, **union** 또는 `enum` 바로 뒤에 옵니다.  태그 이름은 같은 표시 유형을 가진 다른 모든 구조체, 열거형 또는 공용 구조체 태그와 구별되어야 합니다.  
  
 구조체 또는 공용 구조체의 멤버  
 멤버 이름은 각각의 구조체 및 공용 구조체 형식과 연결된 네임스페이스에 할당됩니다.  즉, 같은 식별자가 여러 구조체나 공용 구조체에서 동시에 구성 요소 이름이 될 수 있습니다.  구성 요소 이름의 정의는 항상 구조체 또는 공용 구조체 형식 지정자 안에 발생합니다.  구성 요소 이름은 항상 멤버 선택 연산자\(**–\>** and **.**\) 바로 뒤에 사용됩니다.  멤버 이름은 구조체나 공용 구조체에서 고유해야 하지만 다른 구조체 및 공용 구조체 멤버의 이름이나 구조체 자체의 이름을 포함하여 프로그램에 있는 다른 이름과 구별될 필요는 없습니다.  
  
 일반 식별자  
 다른 모든 이름은 변수, 함수\(정식 매개 변수 및 지역 변수 포함\) 및 열거형 상수가 포함된 네임스페이스에 속합니다.  식별자 이름에 중첩된 표시 유형이 있으므로 블록 안에서 다시 정의할 수 있습니다.  
  
 Typedef 이름  
 같은 범위에서 Typedef 이름을 식별자로 사용할 수 없습니다.  
  
 예를 들어, 구조체 태그, 구조체 멤버 및 변수 이름이 3개의 다른 네임스페이스에 있으므로 이 예제에서 이름이 `student`인 항목 3개가 서로 충돌하지 않습니다.  각 항목의 컨텍스트에서 프로그램에 나오는 각각의 `student`를 정확하게 해석할 수 있습니다. 구조체에 대한 자세한 내용은 [구조체 선언](../c-language/structure-declarations.md)을 참조하십시오.  
  
```  
struct student {  
   char student[20];  
   int class;  
   int id;  
   } student;  
```  
  
 `student`가 `struct` 키워드 다음에 나타나면 컴파일러에서 구조체 태그로 인식합니다.  `student`가 멤버 선택 연산자\(**–\>** 또는 **.**\) 뒤에 나타나면 이름이 구조체 멤버를 참조합니다.  다른 컨텍스트에서는 `student`가 구조체 변수를 참조합니다.  그러나 의미가 불분명해질 수 있으므로 태그 네임스페이스를 오버로드하지 않는 것이 좋습니다.  
  
## 참고 항목  
 [프로그램 구조](../c-language/program-structure.md)